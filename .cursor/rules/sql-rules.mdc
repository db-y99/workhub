---
globs: *.sql
alwaysApply: false
---
**‚ö†Ô∏è CH·ªà √ÅP D·ª§NG CHO FILE SQL:** Rules n√†y ch·ªâ √°p d·ª•ng khi l√†m vi·ªác v·ªõi c√°c file `.sql`, migrations, ho·∫∑c database-related code.

## 2Ô∏è‚É£ MIGRATION FILE NAMING

**Rule:** Migration files ph·∫£i c√≥ naming convention r√µ r√†ng theo format c·ªßa Supabase CLI

**Command:**
```bash
supabase migration new <description>
```

**Format:**
```
{timestamp}_{description}.sql
```

**V√≠ d·ª•:**
```
20260123043207_create_users_table.sql
20260124043207_add_user_email_index.sql
20260125043207_create_user_profiles_table.sql
```

**Rule:**
- ‚úÖ Timestamp format: **`YYYYMMDDHHMMSS`** - 14 digits (Supabase CLI t·ª± ƒë·ªông generate)
- ‚úÖ Description: snake_case, m√¥ t·∫£ r√µ r√†ng migration l√†m g√¨
- ‚úÖ M·ªói migration ch·ªâ l√†m m·ªôt vi·ªác (single responsibility)
- ‚úÖ Migration ph·∫£i reversible (c√≥ th·ªÉ rollback)
- ‚úÖ **KH√îNG t·ª± t·∫°o file migration th·ªß c√¥ng** - lu√¥n d√πng `supabase migration new <name>`

---

## 3Ô∏è‚É£ TABLE & COLUMN NAMING

**Rule:** Consistent naming convention

**Table names:**
- ‚úÖ **snake_case**, **plural**: `users`, `user_profiles`, `order_items`
- ‚úÖ Descriptive, kh√¥ng vi·∫øt t·∫Øt kh√¥ng r√µ r√†ng
- ‚ùå Kh√¥ng d√πng: `tbl_users`, `Users`, `userTbl`

**Column names:**
- ‚úÖ **snake_case**: `user_id`, `created_at`, `full_name`
- ‚úÖ Timestamps: `created_at`, `updated_at`, `deleted_at`
- ‚úÖ Foreign keys: `{table}_id` (e.g., `user_id`, `order_id`)
- ‚úÖ Boolean: `is_active`, `has_permission`, `is_deleted`

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Naming convention
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  full_name TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ‚ùå SAI - Naming kh√¥ng consistent
CREATE TABLE Users (  -- ‚ùå PascalCase
  ID UUID PRIMARY KEY,  -- ‚ùå Uppercase
  Email TEXT,  -- ‚ùå PascalCase
  fullName TEXT,  -- ‚ùå camelCase
  createdDate TIMESTAMPTZ  -- ‚ùå camelCase, kh√¥ng consistent v·ªõi created_at
);
```

---

## 4Ô∏è‚É£ INDEXES & CONSTRAINTS

**Rule:** ƒê·∫∑t t√™n indexes v√† constraints r√µ r√†ng

**Index naming:**
- ‚úÖ Format: `idx_{table}_{columns}`
- ‚úÖ Unique index: `idx_{table}_{columns}_unique`

**Constraint naming:**
- ‚úÖ Primary key: `pk_{table}`
- ‚úÖ Foreign key: `fk_{table}_{referenced_table}`
- ‚úÖ Unique: `uk_{table}_{columns}`
- ‚úÖ Check: `ck_{table}_{description}`

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Named indexes v√† constraints
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email TEXT NOT NULL,
  user_id UUID NOT NULL,
  
  CONSTRAINT pk_users PRIMARY KEY (id),
  CONSTRAINT uk_users_email UNIQUE (email),
  CONSTRAINT fk_users_profiles FOREIGN KEY (user_id) REFERENCES profiles(id)
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at DESC);
CREATE UNIQUE INDEX idx_users_email_unique ON users(email) WHERE deleted_at IS NULL;
```

---

## 5Ô∏è‚É£ FUNCTIONS & TRIGGERS NAMING

**Rule:** Consistent naming cho functions v√† triggers

**Function naming:**
- ‚úÖ **snake_case**: `get_user_by_id`, `update_user_timestamp`
- ‚úÖ Prefix v·ªõi action: `get_`, `create_`, `update_`, `delete_`
- ‚úÖ Descriptive: `get_user_by_email` thay v√¨ `get_user`

**Trigger naming:**
- ‚úÖ Format: `{table}_{action}_{description}`
- ‚úÖ V√≠ d·ª•: `users_before_insert_set_timestamps`, `users_after_update_audit_log`

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Function naming
CREATE OR REPLACE FUNCTION get_user_by_id(user_id UUID)
RETURNS TABLE (
  id UUID,
  email TEXT,
  full_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    u.id,
    u.email,
    u.full_name
  FROM users u
  WHERE u.id = user_id;
END;
$$ LANGUAGE plpgsql;

-- ‚úÖ ƒê√öNG - Trigger naming
CREATE TRIGGER users_before_insert_set_timestamps
  BEFORE INSERT ON users
  FOR EACH ROW
  EXECUTE FUNCTION set_created_at();

CREATE TRIGGER users_after_update_update_timestamp
  AFTER UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();
```

---

## 6Ô∏è‚É£ COMMENTS & DOCUMENTATION

**Rule:** Comment cho complex logic v√† business rules

**Khi n√†o c·∫ßn comment:**
- ‚úÖ Complex queries v·ªõi nhi·ªÅu JOINs
- ‚úÖ Business logic trong functions
- ‚úÖ Non-obvious constraints ho·∫∑c indexes
- ‚úÖ Migration purpose v√† context

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Comment r√µ r√†ng
-- Migration: Add email verification status to users table
-- Reason: Support email verification flow for new user registration
-- Date: 2024-01-01

ALTER TABLE users
  ADD COLUMN email_verified_at TIMESTAMPTZ;

-- Index for fast lookup of unverified users
CREATE INDEX idx_users_email_unverified
  ON users(email)
  WHERE email_verified_at IS NULL;

-- Function to get active users with verified email
-- Returns only users who have verified their email and are not deleted
CREATE OR REPLACE FUNCTION get_active_verified_users()
RETURNS TABLE (
  id UUID,
  email TEXT,
  full_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    u.id,
    u.email,
    u.full_name
  FROM users u
  WHERE
    u.email_verified_at IS NOT NULL  -- Only verified users
    AND u.deleted_at IS NULL;        -- Only active users
END;
$$ LANGUAGE plpgsql;
```

---

## 7Ô∏è‚É£ SECURITY BEST PRACTICES

### Row Level Security (RLS)
**Rule:** Lu√¥n enable RLS cho tables c√≥ sensitive data

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Enable RLS v√† define policies
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  full_name TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only see their own data
CREATE POLICY "Users can view own data"
  ON users
  FOR SELECT
  USING (auth.uid() = id);

-- Policy: Users can update own data
CREATE POLICY "Users can update own data"
  ON users
  FOR UPDATE
  USING (auth.uid() = id);
```

### SQL Injection Prevention
**Rule:** Lu√¥n d√πng parameterized queries, kh√¥ng concatenate user input

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Parameterized query
CREATE OR REPLACE FUNCTION get_user_by_email(user_email TEXT)
RETURNS TABLE (
  id UUID,
  email TEXT,
  full_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    u.id,
    u.email,
    u.full_name
  FROM users u
  WHERE u.email = user_email;  -- ‚úÖ Parameter, kh√¥ng concatenate
END;
$$ LANGUAGE plpgsql;

-- ‚ùå SAI - SQL injection risk
-- WHERE u.email = user_email || '%';  -- ‚ùå N·∫øu user_email c√≥ ch·ª©a SQL
```

---

## 8Ô∏è‚É£ PERFORMANCE OPTIMIZATION

**Rule:** Optimize queries cho performance

### Indexes
- ‚úÖ Index tr√™n columns th∆∞·ªùng d√πng trong WHERE, JOIN, ORDER BY
- ‚úÖ Partial indexes cho filtered queries
- ‚úÖ Composite indexes cho multi-column queries

### Query Optimization
- ‚úÖ Select ch·ªâ columns c·∫ßn thi·∫øt (kh√¥ng `SELECT *`)
- ‚úÖ Use `EXISTS` thay v√¨ `COUNT(*)` khi ch·ªâ c·∫ßn check existence
- ‚úÖ Use `LIMIT` ƒë·ªÉ gi·ªõi h·∫°n k·∫øt qu·∫£

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Optimized v·ªõi indexes
-- Index cho WHERE clause
CREATE INDEX idx_users_email ON users(email);

-- Partial index cho active users
CREATE INDEX idx_users_active
  ON users(id, email)
  WHERE deleted_at IS NULL;

-- Composite index cho multi-column query
CREATE INDEX idx_users_status_created
  ON users(is_active, created_at DESC);

-- ‚úÖ ƒê√öNG - Optimized query
SELECT
  id,
  email,
  full_name
FROM users
WHERE
  email = 'user@example.com'
  AND deleted_at IS NULL
LIMIT 1;

-- ‚úÖ ƒê√öNG - Use EXISTS thay v√¨ COUNT
-- Check if user exists
SELECT EXISTS(
  SELECT 1
  FROM users
  WHERE email = 'user@example.com'
);
```

---

## 9Ô∏è‚É£ MIGRATION BEST PRACTICES

**Rule:** Migration ph·∫£i safe v√† reversible

**Do's:**
- ‚úÖ Add columns v·ªõi `DEFAULT` value ho·∫∑c `NULL`
- ‚úÖ Add constraints v·ªõi `NOT VALID` r·ªìi validate sau
- ‚úÖ Drop columns trong separate migration
- ‚úÖ Test migration tr√™n local tr∆∞·ªõc khi deploy

**Don'ts:**
- ‚ùå Drop columns ngay l·∫≠p t·ª©c (c√≥ th·ªÉ break app ƒëang ch·∫°y)
- ‚ùå Add `NOT NULL` constraint m√† kh√¥ng c√≥ default
- ‚ùå Rename columns tr·ª±c ti·∫øp (d√πng `ALTER COLUMN` v·ªõi migration steps)

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Safe migration
-- Step 1: Add column v·ªõi default
ALTER TABLE users
  ADD COLUMN phone_number TEXT;

-- Step 2: Update existing rows (n·∫øu c·∫ßn)
UPDATE users
SET phone_number = ''
WHERE phone_number IS NULL;

-- Step 3: Add NOT NULL constraint (sau khi ƒë√£ c√≥ data)
ALTER TABLE users
  ALTER COLUMN phone_number SET NOT NULL;

-- ‚ùå SAI - Unsafe migration
ALTER TABLE users
  ADD COLUMN phone_number TEXT NOT NULL;  -- ‚ùå S·∫Ω fail n·∫øu c√≥ existing rows
```

---

## üîü TYPE SAFETY & VALIDATION

**Rule:** D√πng appropriate data types v√† constraints

**Data types:**
- ‚úÖ `UUID` cho primary keys
- ‚úÖ `TEXT` cho strings (kh√¥ng gi·ªõi h·∫°n length)
- ‚úÖ `TIMESTAMPTZ` cho timestamps (timezone-aware)
- ‚úÖ `BOOLEAN` cho flags
- ‚úÖ `JSONB` cho JSON data (indexable)

**Constraints:**
- ‚úÖ `NOT NULL` cho required fields
- ‚úÖ `UNIQUE` cho unique constraints
- ‚úÖ `CHECK` cho validation rules
- ‚úÖ `DEFAULT` cho default values

**V√≠ d·ª•:**
```sql
-- ‚úÖ ƒê√öNG - Type safety v√† validation
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  full_name TEXT,
  age INTEGER CHECK (age >= 0 AND age <= 150),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Index tr√™n JSONB field
CREATE INDEX idx_users_metadata ON users USING GIN (metadata);
```

---

## üìã CHECKLIST KHI VI·∫æT SQL

- [ ] SQL keywords ƒë√£ uppercase?
- [ ] Identifiers ƒë√£ lowercase snake_case?
- [ ] Indentation 2 spaces, code d·ªÖ ƒë·ªçc?
- [ ] Migration file ƒë√£ ƒë√∫ng naming convention?
- [ ] Table/column names ƒë√£ consistent?
- [ ] Indexes v√† constraints ƒë√£ c√≥ t√™n r√µ r√†ng?
- [ ] Functions/triggers ƒë√£ ƒë√∫ng naming?
- [ ] Complex logic ƒë√£ c√≥ comments?
- [ ] RLS ƒë√£ enable cho sensitive tables?
- [ ] Queries ƒë√£ optimized (indexes, LIMIT, EXISTS)?
- [ ] Migration ƒë√£ safe v√† reversible?
- [ ] Data types v√† constraints ƒë√£ ph√π h·ª£p?

---

## üéØ T√ìM T·∫ÆT

**SQL Formatting Principles:**
1. **Consistency** ‚Üí Uppercase keywords, lowercase identifiers
2. **Readability** ‚Üí Proper indentation, line breaks
3. **Naming** ‚Üí snake_case, descriptive names
4. **Security** ‚Üí RLS, parameterized queries
5. **Performance** ‚Üí Indexes, optimized queries
6. **Safety** ‚Üí Reversible migrations, proper types

**M·ª•c ti√™u:**
- üìù Readable v√† maintainable SQL code
- üîí Secure v·ªõi RLS v√† proper constraints
- ‚ö° Performant v·ªõi indexes v√† optimized queries
- üõ°Ô∏è Safe migrations kh√¥ng break production
