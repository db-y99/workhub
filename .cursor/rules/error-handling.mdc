---
alwaysApply: true
---
### 0Ô∏è‚É£ H·∫†N CH·∫æ D√ôNG CLASS

**Rule:** ∆Øu ti√™n **types, interfaces, plain objects v√† factory functions**. Ch·ªâ d√πng class khi th·∫≠t s·ª± c·∫ßn (VD: th∆∞ vi·ªán b√™n ngo√†i y√™u c·∫ßu `instanceof`).

**∆Øu ti√™n:**
- ‚úÖ `type` / `interface` cho error shape
- ‚úÖ `const createError = { ... }` ‚Äî factory tr·∫£ v·ªÅ plain object
- ‚úÖ `Result<T, E>` ‚Äî discriminated union
- ‚ùå `class ValidationError extends Error` ‚Äî tr√°nh tr·ª´ khi b·∫Øt bu·ªôc

**L√Ω do:**
- Tree-shaking, bundle g·ªçn h∆°n
- D·ªÖ serialize (object), kh√¥ng c·∫ßn `instanceof`
- Functional style, ph√π h·ª£p React/Next

---

### 1Ô∏è‚É£ PRIORITIZE ERROR HANDLING AND EDGE CASES

**Rule:** Lu√¥n x·ª≠ l√Ω errors v√† edge cases tr∆∞·ªõc khi implement logic ch√≠nh

**L√Ω do:**
- ƒê·∫£m b·∫£o ·ª©ng d·ª•ng stable v√† reliable
- Tr√°nh crash khi g·∫∑p unexpected data
- C·∫£i thi·ªán user experience

**V√≠ d·ª• (Result, kh√¥ng throw):**
```typescript
// ‚úÖ ƒê√öNG - X·ª≠ l√Ω errors tr∆∞·ªõc, return Result
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';

export const getUserService = async (userId: string): Promise<Result<User | null>> => {
  if (!userId || typeof userId !== 'string') {
    return err(createError.validation('Invalid userId'));
  }
  if (userId.length === 0) return ok(null);

  const supabase = createSupabaseServerClient();
  const { data, error } = await supabase.from('users').select('*').eq('id', userId).single();

  if (error) return err(createError.database(`FETCH_USER_FAILED: ${error.message}`));
  return ok(data);
};

// ‚ùå SAI - Kh√¥ng validate ƒë·∫ßu v√†o
export const getUserService = async (userId: string) => {
  // Logic ch√≠nh ngay ‚Üí c√≥ th·ªÉ crash n·∫øu userId invalid
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('id', userId)
    .single();
  // ...
};
```

---

### 2Ô∏è‚É£ HANDLE ERRORS AT THE BEGINNING OF FUNCTIONS

**Rule:** X·ª≠ l√Ω errors v√† edge cases ·ªü ƒë·∫ßu function, tr∆∞·ªõc khi th·ª±c hi·ªán logic ch√≠nh

**L√Ω do:**
- D·ªÖ ƒë·ªçc v√† maintain
- Fail fast principle
- Tr√°nh th·ª±c hi·ªán logic kh√¥ng c·∫ßn thi·∫øt

**V√≠ d·ª• (Result + plain object):**
```typescript
// ‚úÖ ƒê√öNG - Errors ·ªü ƒë·∫ßu function, return err(...)
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const createUserService = async (userData: CreateUserInput): Promise<Result<User>> => {
  if (!userData.email || !userData.email.includes('@')) {
    return err(createError.validation(ERROR_MESSAGES.INVALID_EMAIL));
  }
  if (!userData.full_name || userData.full_name.trim().length === 0) {
    return err(createError.validation(ERROR_MESSAGES.FULL_NAME_REQUIRED));
  }
  if (userData.email.length > 255) {
    return err(createError.validation(ERROR_MESSAGES.EMAIL_TOO_LONG));
  }

  const supabase = createSupabaseServerClient();
  const { data, error } = await supabase.from('users').insert(userData).select().single();

  if (error) return err(createError.database(`CREATE_USER_FAILED: ${error.message}`));
  return ok(data);
};
```

---

### 3Ô∏è‚É£ USE EARLY RETURNS FOR ERROR CONDITIONS

**Rule:** D√πng early returns ƒë·ªÉ tr√°nh deep nesting v√† tƒÉng readability

**L√Ω do:**
- Code d·ªÖ ƒë·ªçc h∆°n
- Gi·∫£m cognitive load
- Tr√°nh "pyramid of doom"

**V√≠ d·ª•:**
```typescript
// ‚úÖ ƒê√öNG - Early returns
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const processPayment = async (paymentData: PaymentData) => {
  // Early return cho invalid input
  if (!paymentData.amount || paymentData.amount <= 0) {
    return { success: false, error: 'Invalid amount' };
  }

  if (!paymentData.userId) {
    return { success: false, error: ERROR_MESSAGES.USER_ID_REQUIRED };
  }

  // Early return cho edge case
  if (paymentData.amount > 10000) {
    return { success: false, error: 'Amount exceeds limit' };
  }

  // Logic ch√≠nh - kh√¥ng c·∫ßn else
  const result = await chargePayment(paymentData);
  return { success: true, data: result };
};

// ‚ùå SAI - Deep nesting
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const processPayment = async (paymentData: PaymentData) => {
  if (paymentData.amount && paymentData.amount > 0) {
    if (paymentData.userId) {
      if (paymentData.amount <= 10000) {
        const result = await chargePayment(paymentData);
        return { success: true, data: result };
      } else {
        return { success: false, error: 'Amount exceeds limit' };
      }
    } else {
      return { success: false, error: ERROR_MESSAGES.USER_ID_REQUIRED };
    }
  } else {
    return { success: false, error: 'Invalid amount' };
  }
};
```

---

### 4Ô∏è‚É£ UTILIZE GUARD CLAUSES

**Rule:** S·ª≠ d·ª•ng guard clauses ƒë·ªÉ x·ª≠ l√Ω preconditions v√† invalid states s·ªõm

**L√Ω do:**
- Code flow r√µ r√†ng h∆°n
- D·ªÖ test v√† debug
- Tr√°nh nested conditions

**V√≠ d·ª• (Result + plain object, kh√¥ng class):**
```typescript
// ‚úÖ ƒê√öNG - Guard clauses ‚Üí return err(...)
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const updateUserService = async (
  userId: string,
  updates: UpdateUserInput
): Promise<Result<User>> => {
  if (!userId) return err(createError.validation(ERROR_MESSAGES.USER_ID_REQUIRED));
  if (!updates || Object.keys(updates).length === 0) {
    return err(createError.validation(ERROR_MESSAGES.UPDATES_OBJECT_EMPTY));
  }

  const existingResult = await getUserService(userId);
  if (existingResult.ok === false) return err(existingResult.error);

  if (updates.email && !isValidEmail(updates.email)) {
    return err(createError.validation(ERROR_MESSAGES.INVALID_EMAIL_FORMAT));
  }

  const supabase = createSupabaseServerClient();
  const { data, error } = await supabase
    .from('users')
    .update(updates)
    .eq('id', userId)
    .select()
    .single();

  if (error) return err(createError.database(`UPDATE_USER_FAILED: ${error.message}`));
  return ok(data);
};
```

---

### 5Ô∏è‚É£ SERVICE: VALIDATE & TR·∫¢ V·ªÄ RESULT; KH√îNG QUY·∫æT ƒê·ªäNH USER MESSAGE

**üîí RULE C·ª®NG:**
- ‚ùå **Service KH√îNG quy·∫øt ƒë·ªãnh user-facing message**
- ‚úÖ **∆Øu ti√™n: Service tr·∫£ v·ªÅ `Result<T, E>` (error l√† object `{ code, message }`)**
- ‚úÖ **Action / Component layer map `error.code` ‚Üí user message**

**L√Ω do:**
- Service d√πng l·∫°i ·ªü nhi·ªÅu context (API, Action, Component)
- T√°ch bi·ªát business logic v√† presentation
- Result pattern: explicit, type-safe, kh√¥ng c·∫ßn class

**V√≠ d·ª• (Result + plain object):**
```typescript
// ‚úÖ ƒê√öNG - Service return Result, error c√≥ code (kh√¥ng class)
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const deleteUserService = async (userId: string): Promise<Result<true>> => {
  if (!userId) return err(createError.validation(ERROR_MESSAGES.USER_ID_REQUIRED));

  const supabase = createSupabaseServerClient();
  const { error } = await supabase.from('users').delete().eq('id', userId);

  if (error) return err(createError.database('DELETE_USER_FAILED'));
  return ok(true);
};

// ‚úÖ ƒê√öNG - Action unwrap Result, map code ‚Üí user message
'use server';

import { deleteUserService } from '@/services/users/users.service';
import { isErr } from '@/types/result.types';
import { ERROR_CODES } from '@/constants/error-codes';

export const deleteUserAction = async (userId: string) => {
  const r = await deleteUserService(userId);
  if (isErr(r)) {
    const msg = r.error.code === ERROR_CODES.DATABASE
      ? 'Unable to delete user. Please try again later.'
      : r.error.code === ERROR_CODES.VALIDATION
        ? 'Invalid user ID'
        : 'An unexpected error occurred. Please contact support.';
    return { success: false, error: msg };
  }
  return { success: true };
};

// ‚úÖ ƒê√öNG - Component d√πng Action, hi·ªÉn th·ªã message t·ª´ Action
'use client';

import { deleteUserAction } from '@/features/users/actions/delete-user.action';

const DeleteUserButton = ({ userId }: { userId: string }) => {
  const [error, setError] = useState<string | null>(null);

  const handleDelete = async () => {
    const result = await deleteUserAction(userId);
    if (!result.success) setError(result.error);
    // else success handling
  };

  return (
    <div>
      <button onClick={handleDelete}>Delete User</button>
      {error && <div className="error-message">{error}</div>}
    </div>
  );
};

// ‚ùå SAI - Service quy·∫øt ƒë·ªãnh user message
export const deleteUserService = async (userId: string) => {
  if (error) {
    return err({ code: 'DATABASE', message: 'Unable to delete user. Please try again later.' }); // ‚ùå
  }
};
```

---

### 6Ô∏è‚É£ KH√îNG D√ôNG SERVICE TR·ª∞C TI·∫æP TRONG CLIENT COMPONENT

**üîí RULE C·ª®NG:**
- ‚ùå **Kh√¥ng g·ªçi service tr·ª±c ti·∫øp trong Client Component v·ªõi useEffect**
- ‚úÖ **D√πng Server Component, Server Action, ho·∫∑c React Query wrapper**

**L√Ω do:**
- Service l√† server-side code, kh√¥ng n√™n expose tr·ª±c ti·∫øp cho client
- React Query cung c·∫•p caching, refetching, error handling t·ªët h∆°n
- Ph√π h·ª£p v·ªõi App Router architecture

**V√≠ d·ª•:**
```typescript
// ‚ùå SAI - G·ªçi service tr·ª±c ti·∫øp trong Client Component
'use client';

const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    getUserService(userId) // ‚ùå Anti-pattern
      .then(setUser)
      .catch(setError);
  }, [userId]);

  return <div>{user?.email}</div>;
};

// ‚úÖ ƒê√öNG - D√πng React Query wrapper
// hooks/use-users.ts
'use client';

import { useQuery } from '@tanstack/react-query';
import { getUsersClientService } from '@/services/users/users.client';

export const useUserQuery = (userId: string) =>
  useQuery({
    queryKey: ['user', userId],
    queryFn: () => getUsersClientService(userId),
    enabled: Boolean(userId),
  });

// Component
'use client';

import { useUserQuery } from '@/hooks/use-users';

const UserProfile = ({ userId }: { userId: string }) => {
  const { data: user, isLoading, error } = useUserQuery(userId);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{user?.email}</div>;
};

// ‚úÖ ƒê√öNG - D√πng Server Component
// app/users/[id]/page.tsx
import { getUserService } from '@/services/users/users.service';
import UserProfile from '@/components/user-profile.client';

const UserPage = async ({ params }: { params: { id: string } }) => {
  const user = await getUserService(params.id);
  return <UserProfile user={user} />;
};
```

---

### 7Ô∏è‚É£ USE RESULT + PLAIN OBJECT ERRORS (∆ØU TI√äN); TR√ÅNH CLASS

**Rule:** D√πng **Result pattern** + **plain object** (type/interface) + **factory functions**. H·∫°n ch·∫ø class (`ValidationError`, `NotFoundError`, ...).

**L√Ω do:**
- ƒê·ªìng b·ªô v·ªõi **(1) Pattern Result/Error**
- Error l√† data (object), d·ªÖ serialize, kh√¥ng c·∫ßn `instanceof`
- Type-safe, explicit trong signature

**V√≠ d·ª• ‚Äî types + factory (kh√¥ng class):**
```typescript
// constants/error-codes.ts
export const ERROR_CODES = {
  VALIDATION: 'VALIDATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  DATABASE: 'DATABASE_ERROR',
  UNAUTHORIZED: 'UNAUTHORIZED',
} as const;

// constants/error-messages.ts
export const ERROR_MESSAGES = {
  USER_ID_REQUIRED: 'User ID is required',
  UPDATES_OBJECT_EMPTY: 'Updates object cannot be empty',
  INVALID_EMAIL: 'Invalid email address',
  FULL_NAME_REQUIRED: 'Full name is required',
  EMAIL_TOO_LONG: 'Email is too long',
  INVALID_AMOUNT: 'Invalid amount',
  AMOUNT_EXCEEDS_LIMIT: 'Amount exceeds limit',
  INVALID_EMAIL_FORMAT: 'Invalid email format',
} as const;

// types/result.types.ts
export type AppErrorObject = { code: string; message: string; statusCode?: number };
export type Result<T, E = AppErrorObject> = { ok: true; data: T } | { ok: false; error: E };
export const ok = <T>(data: T): Result<T, never> => ({ ok: true, data });
export const err = <E>(error: E): Result<never, E> => ({ ok: false, error });
export const isOk = <T, E>(r: Result<T, E>): r is { ok: true; data: T } => r.ok === true;
export const isErr = <T, E>(r: Result<T, E>): r is { ok: false; error: E } => r.ok === false;

// lib/errors.ts ‚Äî factory (plain object, KH√îNG class)
import { ERROR_CODES } from '@/constants/error-codes';

export const createError = {
  validation: (message: string): AppErrorObject => ({
    code: ERROR_CODES.VALIDATION,
    message,
    statusCode: 400,
  }),
  notFound: (message: string) => ({
    code: ERROR_CODES.NOT_FOUND,
    message,
    statusCode: 404,
  }),
  database: (message: string) => ({
    code: ERROR_CODES.DATABASE,
    message,
    statusCode: 500,
  }),
  unauthorized: (message = 'Unauthorized') => ({
    code: ERROR_CODES.UNAUTHORIZED,
    message,
    statusCode: 401,
  }),
};

// Service ‚Äî return Result
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';
import { ERROR_MESSAGES } from '@/constants/error-messages';

export const getUserService = async (userId: string): Promise<Result<User>> => {
  if (!userId) return err(createError.validation(ERROR_MESSAGES.USER_ID_REQUIRED));

  const supabase = createSupabaseServerClient();
  const { data, error } = await supabase.from('users').select('*').eq('id', userId).single();

  if (error) {
    if (error.code === 'PGRST116') {
      return err(createError.notFound(`User with ID ${userId} not found`));
    }
    return err(createError.database(`FETCH_USER_FAILED: ${error.message}`));
  }
  return ok(data);
};

// hooks/use-users.ts ‚Äî React Query: unwrap Result, throw plain object ƒë·ªÉ gi·ªØ code
'use client';

import { useQuery } from '@tanstack/react-query';
import { getUsersClientService } from '@/services/users/users.client';
import { isErr } from '@/types/result.types';

export const useUserQuery = (userId: string) =>
  useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const r = await getUsersClientService(userId);
      if (isErr(r)) throw r.error; // throw plain object { code, message } ‚Äî React Query c·∫ßn throw
      return r.data;
    },
    enabled: Boolean(userId),
    retry: false,
  });

// Component ‚Äî check error.code (plain object), kh√¥ng instanceof
'use client';

import { useUserQuery } from '@/hooks/use-users';
import { ERROR_CODES } from '@/constants/error-codes';

const UserProfile = ({ userId }: { userId: string }) => {
  const { data: user, isLoading, error } = useUserQuery(userId);

  if (isLoading) return <div>Loading...</div>;
  if (error) {
    const err = error as { code?: string };
    const msg = err?.code === ERROR_CODES.NOT_FOUND ? 'User not found' : err?.code === ERROR_CODES.VALIDATION ? 'Invalid user ID' : 'An error occurred';
    return <div className="error">{msg}</div>;
  }
  return <div>{user?.email}</div>;
};

// Server Component / Page ‚Äî unwrap Result, check error.code (kh√¥ng instanceof)
// app/users/[id]/page.tsx
import { getUserService } from '@/services/users/users.service';
import { isErr } from '@/types/result.types';
import { ERROR_CODES } from '@/constants/error-codes';
import { notFound } from 'next/navigation';

const UserPage = async ({ params }: { params: { id: string } }) => {
  const result = await getUserService(params.id);
  if (isErr(result)) {
    if (result.error.code === ERROR_CODES.NOT_FOUND) notFound();
    throw new Error(result.error.message); // ho·∫∑c redirect
  }
  return <div>{result.data.email}</div>;
};
```

**Khi b·∫Øt bu·ªôc d√πng `throw` (VD: API route, th∆∞ vi·ªán):** wrap trong try/catch r·ªìi convert sang `err(createError.database(...))` n·∫øu mu·ªën gi·ªØ Result trong n·ªôi b·ªô.

---

## üèóÔ∏è ERROR HANDLING ARCHITECTURE RULES

### Service Layer
**Responsibility:**
- ‚ùå **KH√îNG validate input** (validation ·ªü Action layer v·ªõi Zod)
- ‚úÖ Return `Result<T, E>` (E = plain object `{ code, message }`), h·∫°n ch·∫ø `throw` v√† class
- ‚úÖ Kh√¥ng quy·∫øt ƒë·ªãnh user-facing message
- ‚úÖ Kh√¥ng redirect, kh√¥ng log (log ·ªü Action/API)
- ‚úÖ Ch·ªâ l√†m database operation

**‚ö†Ô∏è L∆∞u √Ω:** Input validation B·∫ÆT BU·ªòC ·ªü Action layer v·ªõi Zod. Service ch·ªâ l√†m database operation v·ªõi input ƒë√£ ƒë∆∞·ª£c validate.

**V√≠ d·ª•:**
```typescript
// ‚úÖ ƒê√öNG - Service KH√îNG validate input, ch·ªâ l√†m DB operation
import { Result, ok, err } from '@/types/result.types';
import { createError } from '@/lib/errors';

// Input ƒë√£ ƒë∆∞·ª£c validate ·ªü Action layer v·ªõi Zod ‚Üí kh√¥ng c·∫ßn validate l·∫°i
export const deleteUserService = async (userId: string): Promise<Result<true>> => {
  // userId ƒë√£ ƒë∆∞·ª£c validate ·ªü Action ‚Üí ch·ªâ l√†m DB operation
  const supabase = createSupabaseServerClient();
  const { error } = await supabase.from('users').delete().eq('id', userId);

  if (error) return err(createError.database('DELETE_USER_FAILED'));
  return ok(true);
};
```

### Action / API / Page Layer
**Responsibility:**
- ‚úÖ **B·∫ÆT BU·ªòC: Validate input v·ªõi Zod** tr∆∞·ªõc khi g·ªçi service
- ‚úÖ Unwrap `Result` (`isErr`), kh√¥ng `try/catch` n·∫øu service ƒë√£ d√πng Result
- ‚úÖ Log khi `isErr(result)` v·ªõi `result.error`
- ‚úÖ Map `error.code` ‚Üí user message
- ‚úÖ Redirect n·∫øu c·∫ßn

**V√≠ d·ª•:**
```typescript
// ‚úÖ ƒê√öNG - Action validate input v·ªõi Zod, sau ƒë√≥ g·ªçi service
'use server';

import { logger } from '@/lib/logger';
import { deleteUserService } from '@/services/users/users.service';
import { isErr } from '@/types/result.types';
import { ERROR_CODES } from '@/constants/error-codes';
import { z } from 'zod';

// Schema validation
const DeleteUserSchema = z.object({
  userId: z.string().min(1, 'User ID is required'),
});

export const deleteUserAction = async (formData: FormData) => {
  try {
    // ‚úÖ B·∫ÆT BU·ªòC: Validate input v·ªõi Zod
    const rawInput = { userId: formData.get('userId') };
    const { userId } = DeleteUserSchema.parse(rawInput);

    // Service kh√¥ng validate ‚Üí ch·ªâ l√†m DB operation
    const r = await deleteUserService(userId);
    if (isErr(r)) {
      logger.error('Delete user action failed', { userId, error: r.error });
      const msg = r.error.code === ERROR_CODES.DATABASE
        ? 'Unable to delete user. Please try again later.'
        : 'An unexpected error occurred.';
      return { success: false, error: msg };
    }
    return { success: true };
  } catch (error) {
    // Handle Zod validation errors
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: error.errors.map((e) => e.message).join(', '),
      };
    }
    return { success: false, error: 'An unexpected error occurred.' };
  }
};
```

### Client Layer
**Responsibility:**
- ‚úÖ Kh√¥ng g·ªçi Supabase tr·ª±c ti·∫øp
- ‚úÖ G·ªçi Action/API; nh·∫≠n `{ success, error? }` ‚Äî message ƒë√£ map t·ª´ `error.code`
- ‚úÖ N·∫øu d√πng React Query v·ªõi `throw` trong queryFn: check `(error as { code?: string }).code`, kh√¥ng d√πng `instanceof` class

**V√≠ d·ª•:**
```typescript
// ‚úÖ ƒê√öNG - Client d√πng message t·ª´ Action (ƒë√£ map t·ª´ error.code)
'use client';

import { deleteUserAction } from '@/features/users/actions/delete-user.action';

const DeleteButton = ({ userId }: { userId: string }) => {
  const [error, setError] = useState<string | null>(null);

  const handleDelete = async () => {
    const result = await deleteUserAction(userId);
    if (!result.success) setError(result.error); // message t·ª´ Action
  };

  return (
    <div>
      <button onClick={handleDelete}>Delete</button>
      {error && <div className="error">{error}</div>}
    </div>
  );
};
```

### Logging Best Practices
**Rule:**
- ‚úÖ **Service:** Kh√¥ng log (ch·ªâ throw error)
- ‚úÖ **Action / API:** Log errors v·ªõi context
- ‚úÖ **Client:** Kh√¥ng log (ch·ªâ hi·ªÉn th·ªã message)

**L√Ω do:**
- Service c√≥ th·ªÉ d√πng l·∫°i ·ªü nhi·ªÅu context ‚Üí tr√°nh log tr√πng
- Action/API c√≥ ƒë·∫ßy ƒë·ªß context (request, user, etc.)
- Tr√°nh spam log ·ªü client

---

## üìã CHECKLIST

### Error Handling
- [ ] **(1) Pattern Result/Error** ‚Äî Service tr·∫£ v·ªÅ `Result<T, E>`, `ok`/`err`, `isOk`/`isErr`?
- [ ] **H·∫°n ch·∫ø class** ‚Äî Error l√† plain object `{ code, message }`, `createError` factory, kh√¥ng `ValidationError`/`DatabaseError` class?
- [ ] Errors ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ƒë·∫ßu function?
- [ ] D√πng early returns cho error conditions?
- [ ] Guard clauses ƒë∆∞·ª£c s·ª≠ d·ª•ng?
- [ ] Service return Result (ho·∫∑c throw c√≥ code), kh√¥ng quy·∫øt ƒë·ªãnh user message?
- [ ] **Service KH√îNG validate input (validation ·ªü Action layer v·ªõi Zod)?**
- [ ] **Action/API B·∫ÆT BU·ªòC validate input v·ªõi Zod tr∆∞·ªõc khi g·ªçi service?**
- [ ] Action/API unwrap Result, log v√† map `error.code` ‚Üí user message?
- [ ] Client kh√¥ng g·ªçi service tr·ª±c ti·∫øp (React Query/Server Component); d√πng message t·ª´ Action ho·∫∑c `error.code`?
- [ ] ERROR_CODES, ERROR_MESSAGES d√πng constants?

---

## üéØ T√ìM T·∫ÆT

**Error Handling Principles:**
1. **(1) Result/Error pattern** ‚Üí `Result<T, E>`, `ok`/`err`, `isOk`/`isErr`; ∆∞u ti√™n return thay v√¨ throw
2. **H·∫°n ch·∫ø class** ‚Üí Plain object `{ code, message }` + `createError` factory; tr√°nh Error classes
3. **Fail Fast** ‚Üí Validate v√† handle errors s·ªõm
4. **Early Returns** ‚Üí Tr√°nh deep nesting
5. **Guard Clauses** ‚Üí X·ª≠ l√Ω preconditions tr∆∞·ªõc
6. **Separation of Concerns** ‚Üí Service return Result, Action log & map `error.code`, Client display
7. **Constants** ‚Üí ERROR_CODES, ERROR_MESSAGES

**Architecture Layers:**
- **Service:** Return `Result<T, E>`, `err(createError.xxx(...))` (kh√¥ng log, kh√¥ng user message)
- **Action/API:** Unwrap Result, log, map `error.code` ‚Üí user message
- **Client:** Hi·ªÉn th·ªã message t·ª´ Action ho·∫∑c d·ª±a tr√™n `error.code` (kh√¥ng `instanceof` class)

**M·ª•c ti√™u:**
- üõ°Ô∏è Robust error handling
- üìù Type-safe error handling v·ªõi Result pattern
- üîß Maintainable code v·ªõi constants v√† plain objects
